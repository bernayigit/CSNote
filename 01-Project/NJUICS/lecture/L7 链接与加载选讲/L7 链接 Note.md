
> [!danger] 有时候提出问题比解决问题更重要
> 我们直接对 main.o 进行 objdump, 得到的就是待填充的汇编代码。那么这些待填充的汇编代码什么时候填充呢？应该填充什么呢？这些问题需要仔细思考下。


### 1 为什么用 gcc 链接而不是 ld 链接

> [!chatgpt] 为什么用gcc链接而不是ld链接
> 通常情况下，可以使用 ld 链接器来连接目标文件，生成可执行文件。但使用 gcc 来链接的好处在于，它可以自动地为我们链接一些依赖的库文件。 
> 
> 例如，如果我们的目标文件需要链接 math 库，我们可以通过指定链接选项链接 math 库，像这样：
> 
> ~~~
> ld -o output file1.o file2.o -lm
> ~~~
> 
> 但是，如果只使用 ld 链接器，我们需要手动添加和管理所有的依赖库文件，这可能非常麻烦。使用 gcc 链接器，我们只需要指定我们的源文件，然后 gcc 会自动为我们链接所有需要的库文件，简化了我们的工作流程。

### 2 gcc -static 是什么，有什么好处

> [!chatgpt] gcc -static是什么，有什么好处
> gcc -static是指在编译时使用静态链接库，也就是把所需的函数库和执行文件捆绑在一起生成一个单一的可执行文件。
> 
> 使用静态链接库的好处是可以让程序运行更加稳定可靠，因为程序所需的所有库都已经打包在一起，而不需要依赖系统环境或其他的动态链接库。这使得程序在不同的平台上都能够执行，而不需要担心目标机器是否安装了所需的库。
> 
> 另一方面，使用静态库的缺点是生成的可执行文件大小会变大，因为库的所有内容都需要复制到可执行文件中。而且如果静态链接库有更新，需要重新编译整个程序。

> [!question] 为什么 `.out` 不是字节序列
> 

### 3 NEMU 中 objcopy 的作用
由于 NEMU 解析的是字节序列，不能直接识别 `.elf` 文件，所以我们使用 `objcopy` 将其中的代码和数据拿出来。
```makefile
image: $(IMAGE).elf
	@$(OBJDUMP) -d $(IMAGE).elf > $(IMAGE).txt
	@echo + OBJCOPY "->" $(IMAGE_REL).bin
	@$(OBJCOPY) -S --set-section-flags .bss=alloc,contents -O binary $(IMAGE).elf $(IMAGE).bin
```

> [!chatgpt] objcopy的作用
> 这段代码是一个命令，用于将文件\$(IMAGE).elf转换为$(IMAGE).bin格式的二进制文件。具体含义如下：
> 
> - `@$(OBJCOPY)`：调用objcopy命令进行操作。
> - `-S`：丢弃源文件中所有的符号信息。
> - `--set-section-flags .bss=alloc,contents`：将名为.bss的节(section)标记为可分配和包含内容的。
> - `-O binary`：指定输出格式为二进制文件。
> - `$(IMAGE).elf`：输入的可执行文件。
> - `$(IMAGE).bin`：输出的二进制文件。


### 4 可重定位符号的填充

> [!quote]
> 【[完结] 2020 南京大学计算机系统基础习题课 (蒋炎岩)】 【精准空降到 22:39】 https://www.bilibili.com/video/BV1qa4y1j7xk/?p=7&share_source=copy_web&vd_source=587965785c97101d90acb761204e6795&t=1359

![OJcIkZ](https://picture-suyifan.oss-cn-shenzhen.aliyuncs.com/uPic/OJcIkZ.png)

当我们谈 PC 指针或者 rip 的时候，我们总是谈下一条指针的 PC。

> [!quote]
> As these examples illustrate, the value of the program counter when performing PC-relative addressing is the address of the instruction following the jump, not that of the jump itself. This convention dates back to early implementations, when the processor would update the program counter as its first step in executing an instruction.
> 
> 正如这些例子所说明的那样，在执行相对于程序计数器（PC）的寻址时，程序计数器的值是跳转指令后面一条指令的地址，而不是跳转指令本身的地址。**这个约定可以追溯到早期实现中，当处理器执行一条指令时，它会首先更新程序计数器。**
> 
> [CSAPP 3.6.4](marginnote3app://note/D78B95D4-3FF3-474D-8A69-B1DD1FA73050)
> 

### 5 为什么要有链接？

> [!chatgpt]
> 链接（Linking）在计算机科学中是将多个独立的模块或对象组合成一个可执行的程序或库的过程。链接的目的是解决程序中引用的符号与其对应的定义之间的关联，以及在程序执行过程中如何找到和使用这些定义。
> 
> 下面是一些解释为什么链接是必要的原因：
> 
> 
> 1. **模块化和代码复用**：链接器允许将程序分解为多个模块或文件。每个模块可以独立地编译和调试，这样可以提高开发效率。链接器将这些独立的模块组合在一起，创建一个完整的可执行程序或库。通过模块化和代码复用，链接器促进了软件开发的可维护性和可扩展性。
> 	- 时间上，可以分开编译
> 	- 空间上，无需包含共享库所有代码
> 
> 2. **库的链接**：许多程序使用外部库或模块来提供特定的功能或服务。链接器负责将这些外部库与程序进行链接，以便程序能够调用库中提供的函数和方法。这样，可以在不重复编写代码的情况下重用已有的功能，提高代码的复用性，并减少程序的体积。
> 
> 3. **符号解析和解决符号冲突**：在程序中，可能会引用各种函数、变量和类名等符号。这些符号在编译时只是被声明，而并没有被定义。链接器的主要任务是解析这些符号的引用，并将其与实际的定义关联起来。这样，在程序执行期间，当代码引用这些符号时，链接器就能够找到并正确解析它们。链接器通过符号解析和重定位等技术，解决符号冲突并确保每个符号只有一个定义。
> 
> 4. **地址重定位**：链接器将程序中的相对地址转换为实际的物理地址。这是因为在编译和链接过程中，代码和数据的位置可能会发生变化。链接器负责将这些相对地址映射到正确的物理地址，以便程序能够在内存中正确执行。
> 
> 总之，链接是将程序的各个模块、库和符号关联起来的过程。它解决了符号解析、模块化、代码复用、符号冲突和地址重定位等问题。通过链接，我们可以创建出可执行的程序或库，并确保程序能够正确执行和调用所需的功能。

链接的步骤：
- 确定符号引用关系（符号解析）
- 重定位
	- 合并相关的 `.o` 文件
	- 确定每个符号的地址
	- 在指令中填入新地址


![WrXktQ](https://picture-suyifan.oss-cn-shenzhen.aliyuncs.com/uPic/WrXktQ.png)


> [!question]
> 如果说链接的本质就是合并相同的“节”，那么在合并过程中怎么体现符号解析和重定位呢？（或者说目标文件中的哪些数据结构引导这些操作呢）
> 

### 6 目标文件 #star

目标文件有三种：
- 可重定位目标文件：包含二进制代码和数据，其形式可以在**编译时**与其他可重定位目标文件合并（链接）起来，创建一个可执行目标文件。
- 可执行目标文件：包含二进制代码和数据，其形式可以被直接**复制到内存**并执行。
- 共享目标文件：一种特殊类型的可重定位目标文件，可以在**加载**或者**运行**时被动态地加载进内存并**链接**。

| 可重定位目标文件 | 可执行目标文件 |
| ---------------- | -------------- |
| 被链接的文件     | 被执行的文件   |
| 对应于链接视图   | 对应于执行视图 |
| `.o`             | `.out`         |
| 节头表（可选）           | 程序头表（必选）               |


![cmdLwh|500](https://picture-suyifan.oss-cn-shenzhen.aliyuncs.com/uPic/cmdLwh.png)

![Kemars|500](https://picture-suyifan.oss-cn-shenzhen.aliyuncs.com/uPic/Kemars.png)

### 7 C语言链接过程中，如果标准静态库和自定义静态库函数同名冲突，那么符号解析会链接哪里的函数呢？

> [!chatgpt]
> 在链接过程中，如果你的程序中有一个函数名与标准库或自定义库中的函数名相同，链接器（linker）通常会按照库在**链接命令中的顺序**来解决这个冲突。
> 
> 如果你首先链接了你自定义的库，然后再链接标准库，链接器在搜索符号时首先查找你的自定义库。如果它在你的自定义库中找到了这个符号（函数），它就会停止搜索，并将此符号链接到你的程序中。这就意味着，如果一个函数在自定义库和标准库中都存在，而自定义库被首先链接，那么自定义库中的函数将被使用。
> 
> 但是，请注意，这种行为可能会因编译器或链接器的具体实现而有所不同，可能也会受到一些链接选项的影响。在实际编程中，最好避免此类冲突，因为这可能会导致程序行为难以预测或理解。如果无法避免这种冲突，你应该查阅你所使用的编译器和链接器的文档，了解它们如何处理此类情况。

