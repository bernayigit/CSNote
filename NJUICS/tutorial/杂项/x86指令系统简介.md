i386手册有一章专门列出了所有指令的细节, 附录中的 opcode map 也很有用. 在这里, 我们先对 x86指令系统作一些简单的梳理. 当你对 x86指令系统有任何疑惑时, 请查阅 i386手册, 关于指令系统的一切细节都在里面.


>[!notice] i386 手册勘误
>
>由于 PDF 版本的 i386 手册的印刷错误较多, 一定程度上影响理解, 我们在 github 上开放了一个 [repo](https://github.com/NJU-ProjectN/i386-manual), 用于提供修复印刷错误的版本. 同时我们也为修复错误后的版本提供在线的 [HTML版本](https://nju-projectn.github.io/i386-manual/toc.htm).
>
>如果你在做实验的过程中也发现了新的错误, 欢迎帮助我们修复这些错误.

## 指令格式

x86指令的一般格式如下:

```
+---------+----------+-----------+--------+------+------+------+------------+----------+
|instructi| address- |  operand- |segment |opcode|ModR/M| SIB  |displacement| immediate|
|  prefix |sizeprefix|size prefix|override|      |      |      |            |          |
|---------+----------+-----------+--------+------+------+------+------------+----------|
|  0 OR 1 |  0 OR 1  |   0 OR 1  | 0 OR 1 |1 OR 2|0 OR 1|0 OR 1| 0,1,2 OR 4 |0,1,2 OR 4|
|- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
|                                  number of bytes                                     |
+--------------------------------------------------------------------------------------+
```

除了opcode(操作码)必定出现之外, 其余组成部分可能不出现, 而对于某些组成部分, 其长度并不是固定的. 但给定一条具体指令的二进制形式, 其组成部分的划分是有办法确定的, 不会产生歧义(即把一串比特串看成指令的时候, 不会出现两种不同的解释). 例如对于以下指令:

```
100017:    66 c7 84 99 00 e0 ff ff 01 00      movw   $0x1,-0x2000(%ecx,%ebx,4)
```

其组成部分的划分如下:

```
+----------+-----------+-----------+--------+------+------+-----+------------+---------+sssss
|instructio| address-  |  operand- |segment |opcode|ModR/M| SIB |displacement|immediate|
|  prefix  |size prefix|size prefix|override|      |      |     |            |         |
|----------+-----------+-----------+--------+------+------+-----+------------+---------|
|                           66                 c7     84     99   00 e0 ff ff   01 00  |
+--------------------------------------------------------------------------------------+
```

凭什么`0x84`要被解释成`ModR/M`字节呢? 这是由`opcode`决定的, `opcode`决定了这是什么指令的什么形式, 同时也决定了`opcode`之后的比特串如何解释. 如果你要问是谁来决定`opcode`, 那你就得去问Intel了.

PA中的x86经过简化, `address-size prefix`和`segment override prefix`都不会用到, 因此NEMU也不需要实现这两者的功能.